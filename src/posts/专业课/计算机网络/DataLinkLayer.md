# Data Link Layer (数据链路层)

## Function( 功能)

- **服务接口** 向网络层提供一个服务接口
  三种服务：
  - 无确认的无连接服务
    - 错误率低
    - 实时性高
    - Most LANs
  - 有确认的无连接服务
    - 不可靠，但是每帧都会确认
    - 例如无线局域网，802.11
  - 有确认的面向连接服务
    - WAN, P2P
    - 建立连接、传输帧、释放
    - 确保每一帧刚好传输一次、帧有序
- **成帧** 将网络层传下来的数据封装成帧
  - 帧头：帧同步、帧长度、帧校验序列
  - 有效载荷：数据
  - 帧尾：帧校验序列
  > 数据包和帧的关系：数据包是网络层传下来的，帧是数据链路层传下去的
- **传输错误处理** 比如检错、纠错
- **调节数据流量** 比如流量控制，确保发送方不会淹没接收方

## Framing (成帧)

- **字节计数法**：帧头中包含一个计数字段，表示帧中字节数
- **标志字节法**：帧头和帧尾包含特殊的字节，用于标识帧的开始和结束
- **标志比特法**：帧头和帧尾包含特殊的比特模式，用于标识帧的开始和结束
- **物理层违例编码法**：利用物理层编码违例外，标识帧的开始和结束

> 备注：此处字节=字符

### 字符计数

每一帧开头都有一个字符（character），表示这一帧总共有多少字符。

> **问题**

如果发生传输错误，接收方就会失去同步，找不到帧开始的位置，发送方也不知道从哪里开始重传

### 标志字节法

每一帧开头和结尾都有一个特殊的字符，称为标志字节（flag byte），表示帧的开始和结束。
如果接收方失去同步，只需要搜索两个标志字符就能找到当前帧的的结束位置、下一帧的开始位置。

> **问题**

如果数据中恰好出现标志字节，就会产生冲突，称为**冲突逃逸字符**（escape character）

> 解决方案：**字节填充（byte stuffing）**
  - 如果数据中恰好出现标志字节，就在它前面加上一个特殊的字符，称为转义字符（escape character）
  - 接收方的数据链路层在传输给网络层前需要处理转义字符
  - 如果数据中恰好出现转义字符，就在它前面再加上一个转义字符
  - 填充方案举例：PPP（Point-to-Point Protocol）

> 缺点：8比特的字节来区分边界，效率低

### 标志比特法

每一帧开头和结尾都有一个特殊的比特模式，称为标志比特（flag bit），表示帧的开始和结束。

> **比特填充**
  - 以六个连续的1，即111111作为定界符
  - 如果数据中恰好出现六个连续的1，当遇到5个连续的1时，在后面插入一个比特0
  - 接收方的数据链路层在传输给网络层前需要处理比特填充，遇到5个连续的1时，删除后面插入的比特0

> **相比标志字符法**
>  - 传输效率高
>  - 划分级别在比特级别，而不是字符级别
>  - 帧可以包含任意大小单元

现实中的运用例子：USB

### 物理层违例编码法
 
核心思想：选择的定界符不会在数据中出现

方案：
1. 4B/5B
2. 前导码
  - 存在很长的前导码，可以用作定界符
  - **例子**： 以太网，802.11
3. 曼彻斯特编码
  - 周期性的跳变，可以用作定界符

## Error Control (错误控制)

> **错误**
> - 差错
> - 丢失
> - 乱序
> - 重复

> **解决方案**
> - [eror detection (检错)](#error-detection-and-correction-检错和纠错)
> - Feedback: 反馈
>   - Positive Acknowledgment (PA)
>   - Negative Acknowledgment (NA)
> - Timer：计时器
> - Sequence Number：序列号

## 流量控制

### feedback-based flow control(基于反馈的流量控制)

### rate-based flow control(基于速率的流量控制)

## Error Detection and Correction (检错和纠错)

### 策略

1. 纠错码，使用纠错码的技术叫FEC（Forward Error Correction）
  - 在发送的数据中包含信息，让接受发推断发生了什么错误 (what)
  - 适用于容易出错的、有噪声的信道，例如无线链路
2. 检错码
  - 在发送的数据中包含信息，让接受方判断数据是否出错（is）
  - 适用于不容易出错的，例如光纤

### 两种错误模型

1. 单比特错误:极端热噪声淹没了信号
2. 突发性错误（源自物理过程）

**对比**：
- 多个单比特，如果错误是独立的，可能覆盖覆盖范围很广，导致多个数据块出错
- 突发错误一般集中在一个数据块，但是这比单个比特更难纠正

> **补充：erase channel(擦除信道):**
> 接受的模拟信号远离了0，1的预期值，相比于比特翻转，这更容易发现那个bit出错了。

### 纠错码

将冗余信息加入数据：m个数据位，r个冗余位，总共有n=m+r个位
码字：数据位和冗余位组成的序列
码率：数据位和码字的比率，m/n

- **海明距离**：两个码字之间，对应位置不同字符的个数
  - 例如：0000000000, 0000011111, 1111100000, and 1111111111
  - Hamming distance is 5，因为任意字串之间转换都需要改变5个字符
- **最小海明距离**：两个码字之间，对应位置不同字符的最小个数
- 为了检测d个错误，需要d+1的编码方案
- 为了纠正d个错误，需要2d+1的编码方案

> **例子**
> 0000000000, 0000011111, 1111100000, 1111111111, 距离为5，那么它可以纠正最多2个错误
> 比如如果是发送了0000011111，接收方收到了0000000111，发生了两个错误，那么接受发还是可以选择最接近的0000011111，从而纠正错误
> 比如如果是发送了0000000000，接收方收到了0000000111，那么它就不能正确的纠错了

校验位数量如何最少：$m+r+1 <= 2^r$

#### Hamming Code（海明码）

海明码能发现`多位错误`,但只能纠正`一位错误`，若用在纠正传输中出现突发性差错时可以采用下述方法:将连续P个码字排成一个矩阵，每行一个码字。如果发生突发长度≤P的突发错误，那么在P个码字中最多每个码字有一位有差错，正好由海明码能纠正。

> - **确定编码数量**：
>   - 由 $2^r >= m+r+1$，可以确定需要r个校验位
> - **确定每个校验位的位置**：
>   - 从1开始，2的幂次方，即1, 2, 4, 8, 16, 32, 64, 128, ...
> - 拼接校验位和数据位，得到n+r位的码字
> - **校验位的值**：
>   - 对于第i（i=1,2,3...）个校验位，从当前校验位所在位置开始（校验位初始化值为0），若用一个tmp来表示校验位的值，tmp = 0，将tmp^=码字位，并且每隔 $2^（i-1）$ 个位置再次异或，得到校验位的值。
>   - （校验位的值的意义就是判断这些统计的部分里的1的个数是否为奇数（tmp=1）或偶数（tmp=0））

接收方收到码字后，用同样的方法计算新的校验位的值，并将重新计算出来的校验位依次，从二进制低位到高位排列
> - 如果二进制数最终代表0，那么就没有错误
> - 否则，如果出错了一位，那么二进制所代表的数就是码字出错的位置
>   - 纠正：将计算出来的出错位置取反，得到正确的码字

### 检错码

#### (odd/even) Parity(奇偶校验)

- **奇校验**：校验位使得原来的数据加入校验位后，每个校验位校验的范围内，1的个数是奇数
- **偶校验**：同上，只是为偶数了

![img](/专业课/计算机网络/Parity.png)

#### Checksums(校验和)

检验部位：IP头部，数据正文不参与校验计算

[详细计算原理和实现，这文讲的还行](https://blog.csdn.net/qq_37174526/article/details/88407884)

- **计算**：将数据包中的所有字相加（加法有溢出要`回卷`），然后取反码，得`检验和`
- **校验**：将检验和与数据包中的所有字相加，然后取反码，如果结果为0，那么数据包没有错误

#### CRC (Cyclic Redundancy Check)

- **商定生成多项式是什么：** 我们设生成多项式为 $G(x)$
- **计算生成多项式的阶数：** 设阶数为 $r$，其满足 $2^r-1 < bitCount(G(x)) < 2^r$ 
- **计算：** 在帧后面补上 $r$ 个0，得到 $x^rM(x)$ 然后用`模2除法(用异或代替了减法)`除 $x^rM(x)$，得到余数 $R(x)$ ，余数就是检验位
- **发送：** 设 $ T(x) = x^rM(x) + R(x) $，发送 $T(x)$
  - > 显然 $T(x)$ 可被 $G(x)$ 整除，因为 $T(x) = x^rM(x) + R(x) = [K*G(x) + R(x)] + R(x) = K*G(x) $，（相同的数异或加减结果为0）

## 基本数据链路层协议

> NIC: Network Interface Card(网络接口卡)

> 数据包和帧：网络层从传输层获得报文，加上网络层头以创建数据包，传递给链路层，链路层将数据包装在帧的info中

### 单工协议

#### 乌托邦式的单工协议

完全没有异常发生。

- **发送方** 
  - 从网络层获取数据包
  - 将数据包放入帧中
  - 向物理层发送帧
- **接收方**
  - 等待事件
  - 从物理层接收帧
  - 将帧中的数据包交给网络层


#### 无错信道的单工协议

> 考虑了发送方淹没接收方，进行了流量控制。
> 由于需要接收方反馈一个哑帧（确认），需要一个半双工信道
> 停-等式协议

- **发送方**
  - 从网络层获取数据包
  - 将数据包放入帧中
  - 向物理层发送帧
  - 等待事件（等待接收方发送回来的哑帧）
- **接收方**
  - 等待事件
  - 从物理层接收帧
  - 将帧中的数据包交给网络层
  - 发送确认帧

#### 有错信道的单工停-等式协议

> 考虑帧传输的丢失、帧传输的重复
> 计时器（发送发判断超时）、序列号（接收方区分重复）
> ARQ、PAR


- **计时器** 发送方在发送帧后启动计时器，如果计时器超时，那么就重新发送当前帧(如果仅仅是因为接收方的确认帧丢失了导致的超时，就有可能发生重复帧的情况)
- **序列号** 由于我们只关心当前帧是否达到，而决定我们下一帧是发送当前帧还是后一帧，所以用一位0/1足够区分了
  - 接受方收到重复帧和受损帧，只需要重传最后一次正确接受到的帧的序号就可以让发送新帧或者重新发送受损帧

### 双向通信的协议

> 实际情况需要双方计算机同时互相传输一些数据

- **全双工信道** 
  - 一个用来发送数据，一个用来发送确认。
  - 缺点是浪费逆向信道的带宽。
- **piggybacking(捎带确认)** 
  - 一个机器向另一个机器的数据帧和确认帧可以一起发送。
  - 优点：省带宽,并且减少了发送的帧的数量（节省了帧头）
  - 缺点：发送一个确认帧可能还需要等待本机的网络层发数据包下来
  - 缺点改进：当一段时间内确实没有数据包发下来，就发送一个单独的确认帧

#### 滑动窗口协议

**基本工作模式**

- **发送方** 
  - 维持一组`序列号`，任何时候发送的帧的数量都不能超过MAX_SEQ
  - 窗口内代表从网络层获取后还处于没被确认接受的帧
  - 如果窗口大小达到上界，暂时停止从网络层接受数据包
  - **累计确认：**如果第n帧被ACK了，那么表示n之前的帧都已经被ACK了
- **接收方**
  - 窗口内代表等待接受的帧，任何落在窗口内的帧都在链路层缓存
  - 如果窗口下界刚好有已经接受了的帧，那么就把数据包解析给网络层，窗口下界+1
- **关键词**
  - `sending window` 发送窗口
  - `receiving window` 接收窗口
  - 序号空间
  - $ MAX_SEQ = 2^n - 1$

##### **一位滑动窗口协议**

> 其实就是一个窗口大小为 1 的情况的示例，类似1位停-等式协议

**伪代码：**由于是双向通信，两方的代码是一样的

```c
void protocol () {
  init();
  frame, buffer
  while(true){
    wait_event(&e);
    if(e.type == frame_arrival){ // 截断式分支
      get_frame_from_physical_layer(&frame);
      if(frame.seq == expect_seq){ // 获取正确
        to_network_layer(frame.info);
        incre_expect_seq();
      }
      if(frame.ack == next_frame_seq){ // 发送成功，拉取新数据包
        clear_timer();
        get_frame_from_network_layer(& buffer);
        incre_next_frame_seq();
      }
    }
    packet = make_frame(buffer, /*发送的帧序号*/ next_frame_seq, /*确认*/ expect_seq);
    send_to_physical_layer(packet);
    start_timer();
  }
}

```

**问题：** 双方可能如图右所示，帧的接受交错，导致帧重复发送。
例如A发送了A0后，由于接收到了B的初始状态（0，1），导致A认为B接受失败了，又重新发送了A0，这样严重浪费了带宽。
 
![一位滑动窗口异常](/专业课/计算机网络/1滑动窗口异常.png)

##### **回退N协议**

> **场景：** 如果双方通信延迟较高，那么他们对带宽的实际利用很低（基本都在等待）
> 如果发送下一帧的前提是确保接收方确认接受了，那么是无法避免这样的结果的

我们发送方在阻塞之前可以发送多达W帧，并且有足够的窗口大小，并且当确认帧返回时我们的窗口应该没有被填满，这种情况下就可以尽量地保证发送发持续发送帧

怎么找到w的值，也就是我们这个通信通道最多可以有多少帧在信道中同时传输，`帧数/(窗口容量) w`依赖于`带宽 B`和`单向传输时间 D`

考虑回路，以及接收方正在处理一个帧，总容量:

$$
w=2BD+1
$$

当W比2BD+1小的时候，更容易被阻塞，所以

$$
链路利用率 <= \frac{w}{2BD+1}
$$

显然，w必须要足够大，这还是不考虑帧的接受处理、ACK帧长度的情况

**管道化（pipelining）**保持多个帧在信道中传输
  - **主要问题：**解决管道传输错误的情况
  - **策略权衡值：**链路层的缓存大小、带宽利用率
  - **解决方法：**
    - **窗口大小为1（回退n）** 如果发生一个错误帧，（由于接收方只有一个缓冲区，没法多收，而发送方必须维持所有的未确认帧）接收方就忽略后续到达的所有其他帧，当发送方超时后，从错误帧开始重新传输。不适合信道错误率高的情况
    - **窗口大小较大（选择重传）** 如果发生一个错误帧，接收方可以用窗口缓存后续正确的帧，并向接收方发送一个NAK（Negative Acknowledgement），发送方收到NAK后，重新传输错误帧。
    接收方可以继续从上一次正确接受的帧开始发送ACK，这样就避免了重复传输中间的正确帧的情况。

> **如何用软件模拟计时器超时**
> ![基于链表的软件模拟](/专业课/计算机网络/软件计时器.png )

##### **选择重传协议**

刚才管道化已经简单介绍了，这里再补充一下

> 双方各自维护窗口，发送方从0开始，可以增大到一个预定的最大值
> 接收方窗口大小固定，每个缓冲区都有一个`标志位（arrived）`，表示该帧是否已经接受
> 接收方只处理落入当前窗口内的帧

我们可以看到，选择重传是一种非顺序接受的方式。

对于一般的非顺序接受，但是如果发生某些传输异常，这个协议就是不正确的，比如：

> ![非顺序接受异常](/专业课/计算机网络/非顺序接受异常.png )
> 初始为（a）图
> 当接收方正确接受了7个帧后，发送ACK 7回去时，由于一些异常导致ACK没有传到发送方，此时发送方超时，但是接收方已经生成了新的窗口（窗口是循环使用的）
> 发送方重新发送0帧，但是接收方的0处已经是新窗口了，因此它占据了原本新窗口的数据，导致这给网络层的将是错误的数据包。协议失败
> （说实话，其实如果接受到新的正确0时，对这个位置的进行覆写就行了，但是这样就失去了标志位（arrived）的意义，并且还消耗一点点性能，所以协议没有选择这么做）
> **原因：**新窗口与老窗口重叠
> **解决：**窗口大小不超过序号空间的 $ 1/2 $

**计时器**

需要的计时器数量和缓冲区数量一样多

**接收方的辅助计时器**

> 如果A发送给B的流量大，但是反向流量小，由于采用了捎带确认，这样A->B很容易阻塞

我们在接收方需要一个辅助计时器，对应一个缓冲区，如果在短时间内没有需要发送的反向流量，那么就发送一个单独的确认帧，这样可以避免A轻易地陷入阻塞

当然，计时器应该尽可能更短，因为更快的确认帧达到，可以避免发送方重传

**NAK**

由接受方管理，用于请求发送方重传指定的帧，发送方要记下某帧是否已经发过NAK了，避免多次请求同一个帧

## 附录补充

- L:发送数据的大小
- B:带宽
- D:单向传输时间
- W:窗口大小
- $\eta$:效率

### 效率公式的核心内容:

$$
\frac{发送方有效数据的发送时间}{从发送方开始发送到收到确认帧的总时间}
$$

[此文很详细，可以参考](https://blog.csdn.net/Wang_Dou_Dou_/article/details/123620115)

### GobackN 协议的最大发送窗口

$$
W = 2^n -1
$$

### T1信道传输速率

$$
1.544Mbps
$$