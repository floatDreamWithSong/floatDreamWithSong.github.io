# Data Link Layer (数据链路层)

## Function( 功能)

- **服务接口** 向网络层提供一个服务接口
  三种服务：
  - 无确认的无连接服务
    - 错误率低
    - 实时性高
    - Most LANs
  - 有确认的无连接服务
    - 不可靠，但是每帧都会确认
    - 例如无线局域网，802.11
  - 有确认的面向连接服务
    - WAN, P2P
    - 建立连接、传输帧、释放
    - 确保每一帧刚好传输一次、帧有序
- **成帧** 将网络层传下来的数据封装成帧
  - 帧头：帧同步、帧长度、帧校验序列
  - 有效载荷：数据
  - 帧尾：帧校验序列
  > 数据包和帧的关系：数据包是网络层传下来的，帧是数据链路层传下去的
- **传输错误处理** 比如检错、纠错
- **调节数据流量** 比如流量控制，确保发送方不会淹没接收方

## Framing (成帧)

- **字节计数法**：帧头中包含一个计数字段，表示帧中字节数
- **标志字节法**：帧头和帧尾包含特殊的字节，用于标识帧的开始和结束
- **标志比特法**：帧头和帧尾包含特殊的比特模式，用于标识帧的开始和结束
- **物理层违例编码法**：利用物理层编码违例外，标识帧的开始和结束

> 备注：此处字节=字符

### 字符计数

每一帧开头都有一个字符（character），表示这一帧总共有多少字符。

> **问题**

如果发生传输错误，接收方就会失去同步，找不到帧开始的位置，发送方也不知道从哪里开始重传

### 标志字节法

每一帧开头和结尾都有一个特殊的字符，称为标志字节（flag byte），表示帧的开始和结束。
如果接收方失去同步，只需要搜索两个标志字符就能找到当前帧的的结束位置、下一帧的开始位置。

> **问题**

如果数据中恰好出现标志字节，就会产生冲突，称为**冲突逃逸字符**（escape character）

> 解决方案：**字节填充（byte stuffing）**
  - 如果数据中恰好出现标志字节，就在它前面加上一个特殊的字符，称为转义字符（escape character）
  - 接收方的数据链路层在传输给网络层前需要处理转义字符
  - 如果数据中恰好出现转义字符，就在它前面再加上一个转义字符
  - 填充方案举例：PPP（Point-to-Point Protocol）

> 缺点：8比特的字节来区分边界，效率低

### 标志比特法

每一帧开头和结尾都有一个特殊的比特模式，称为标志比特（flag bit），表示帧的开始和结束。

> **比特填充**
  - 以六个连续的1，即111111作为定界符
  - 如果数据中恰好出现六个连续的1，当遇到5个连续的1时，在后面插入一个比特0
  - 接收方的数据链路层在传输给网络层前需要处理比特填充，遇到5个连续的1时，删除后面插入的比特0

> **相比标志字符法**
>  - 传输效率高
>  - 划分级别在比特级别，而不是字符级别
>  - 帧可以包含任意大小单元

现实中的运用例子：USB

### 物理层违例编码法
 
核心思想：选择的定界符不会在数据中出现

方案：
1. 4B/5B
2. 前导码
  - 存在很长的前导码，可以用作定界符
  - **例子**： 以太网，802.11
3. 曼彻斯特编码
  - 周期性的跳变，可以用作定界符

## Error Control (错误控制)

> **错误**
> - 差错
> - 丢失
> - 乱序
> - 重复

> **解决方案**
> - [eror detection (检错)](#error-detection-and-correction-检错和纠错)
> - Feedback: 反馈
>   - Positive Acknowledgment (PA)
>   - Negative Acknowledgment (NA)
> - Timer：计时器
> - Sequence Number：序列号

## 流量控制

### feedback-based flow control(基于反馈的流量控制)

### rate-based flow control(基于速率的流量控制)

## Error Detection and Correction (检错和纠错)

### 策略

1. 纠错码，使用纠错码的技术叫FEC（Forward Error Correction）
  - 在发送的数据中包含信息，让接受发推断发生了什么错误 (what)
  - 适用于容易出错的、有噪声的信道，例如无线链路
2. 检错码
  - 在发送的数据中包含信息，让接受方判断数据是否出错（is）
  - 适用于不容易出错的，例如光纤

### 两种错误模型

1. 单比特错误:极端热噪声淹没了信号
2. 突发性错误（源自物理过程）

**对比**：
- 多个单比特，如果错误是独立的，可能覆盖覆盖范围很广，导致多个数据块出错
- 突发错误一般集中在一个数据块，但是这比单个比特更难纠正

> **补充：erase channel(擦除信道):**
> 接受的模拟信号远离了0，1的预期值，相比于比特翻转，这更容易发现那个bit出错了。

### 纠错码

将冗余信息加入数据：m个数据位，r个冗余位，总共有n=m+r个位
码字：数据位和冗余位组成的序列
码率：数据位和码字的比率，m/n

- **海明距离**：两个码字之间，对应位置不同字符的个数
  - 例如：0000000000, 0000011111, 1111100000, and 1111111111
  - Hamming distance is 5，因为任意字串之间转换都需要改变5个字符
- **最小海明距离**：两个码字之间，对应位置不同字符的最小个数
- 为了检测d个错误，需要d+1的编码方案
- 为了纠正d个错误，需要2d+1的编码方案

> **例子**
> 0000000000, 0000011111, 1111100000, 1111111111, 距离为5，那么它可以纠正最多2个错误
> 比如如果是发送了0000011111，接收方收到了0000000111，发生了两个错误，那么接受发还是可以选择最接近的0000011111，从而纠正错误
> 比如如果是发送了0000000000，接收方收到了0000000111，那么它就不能正确的纠错了

校验位数量如何最少：m+r+1 <= 2^r

#### Hamming Code（海明码）

海明码能发现多位错误,但只能纠正一位错，若用在纠正传输中出现突发性差错时可以采用下述方法:将连续P个码字排成一个矩阵，每行一个码字。如果发生突发长度≤P的突发错误，那么在P个码字中最多每个码字有一位有差错，正好由海明码能纠正。

> - 确定编码数量：
>   - 由2^r >= m+r+1，可以确定需要r个校验位
> - 确定每个校验位的位置：
>   - 从1开始，2的幂次方，即1, 2, 4, 8, 16, 32, 64, 128, ...
> - 拼接校验位和数据位，得到n+r位的码字
> - 校验位的值：
>   - 对于第i（i=1,2,3...）个校验位，从当前校验位所在位置开始（校验位初始化值为0），若用一个tmp来表示校验位的值，tmp = 0，将tmp^=码字位，并且每隔2^（i-1）个位置再次异或，得到校验位的值。
>   - （校验位的值的意义就是判断这些统计的部分里的1的个数是否为奇数（tmp=1）或偶数（tmp=0））

接收方收到码字后，用同样的方法计算新的校验位的值，并将重新计算出来的校验位依次，从二进制低位到高位排列
> - 如果二进制数最终代表0，那么就没有错误
> - 否则，如果出错了一位，那么二进制所代表的数就是码字出错的位置
>   - 纠正：将计算出来的出错位置取反，得到正确的码字