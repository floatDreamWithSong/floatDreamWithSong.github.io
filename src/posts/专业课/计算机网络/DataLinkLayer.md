# Data Link Layer (数据链路层)

## Function( 功能)

- **服务接口** 向网络层提供一个服务接口
  三种服务：
  - 无确认的无连接服务
    - 错误率低
    - 实时性高
    - Most LANs
  - 有确认的无连接服务
    - 不可靠，但是每帧都会确认
    - 例如无线局域网，802.11
  - 有确认的面向连接服务
    - WAN, P2P
    - 建立连接、传输帧、释放
    - 确保每一帧刚好传输一次、帧有序
- **成帧** 将网络层传下来的数据封装成帧
  - 帧头：帧同步、帧长度、帧校验序列
  - 有效载荷：数据
  - 帧尾：帧校验序列
  > 数据包和帧的关系：数据包是网络层传下来的，帧是数据链路层传下去的
- **传输错误处理** 比如检错、纠错
- **调节数据流量** 比如流量控制，确保发送方不会淹没接收方

## Framing (成帧)

- **字节计数法**：帧头中包含一个计数字段，表示帧中字节数
- **标志字节法**：帧头和帧尾包含特殊的字节，用于标识帧的开始和结束
- **标志比特法**：帧头和帧尾包含特殊的比特模式，用于标识帧的开始和结束
- **物理层违例编码法**：利用物理层编码违例外，标识帧的开始和结束

> 备注：此处字节=字符

### 字符计数

每一帧开头都有一个字符（character），表示这一帧总共有多少字符。

> **问题**

如果发生传输错误，接收方就会失去同步，找不到帧开始的位置，发送方也不知道从哪里开始重传

### 标志字节法

每一帧开头和结尾都有一个特殊的字符，称为标志字节（flag byte），表示帧的开始和结束。
如果接收方失去同步，只需要搜索两个标志字符就能找到当前帧的的结束位置、下一帧的开始位置。

> **问题**

如果数据中恰好出现标志字节，就会产生冲突，称为**冲突逃逸字符**（escape character）

> 解决方案：**字节填充（byte stuffing）**
  - 如果数据中恰好出现标志字节，就在它前面加上一个特殊的字符，称为转义字符（escape character）
  - 接收方的数据链路层在传输给网络层前需要处理转义字符
  - 如果数据中恰好出现转义字符，就在它前面再加上一个转义字符
  - 填充方案举例：PPP（Point-to-Point Protocol）

> 缺点：8比特的字节来区分边界，效率低

### 标志比特法

每一帧开头和结尾都有一个特殊的比特模式，称为标志比特（flag bit），表示帧的开始和结束。

> **比特填充**
  - 以六个连续的1，即111111作为定界符
  - 如果数据中恰好出现六个连续的1，当遇到5个连续的1时，在后面插入一个比特0
  - 接收方的数据链路层在传输给网络层前需要处理比特填充，遇到5个连续的1时，删除后面插入的比特0

> **相比标志字符法**
>  - 传输效率高
>  - 划分级别在比特级别，而不是字符级别
>  - 帧可以包含任意大小单元

现实中的运用例子：USB

### 物理层违例编码法
 
核心思想：选择的定界符不会在数据中出现

方案：
1. 4B/5B
2. 前导码
  - 存在很长的前导码，可以用作定界符
  - **例子**： 以太网，802.11
3. 曼彻斯特编码
  - 周期性的跳变，可以用作定界符

## Error Control (错误控制)

> **错误**
> - 差错
> - 丢失
> - 乱序
> - 重复

> **解决方案**
> - [eror detection (检错)](#error-detection-and-correction-检错和纠错)
> - Feedback: 反馈
>   - Positive Acknowledgment (PA)
>   - Negative Acknowledgment (NA)
> - Timer：计时器
> - Sequence Number：序列号

## 流量控制

### feedback-based flow control(基于反馈的流量控制)

### rate-based flow control(基于速率的流量控制)

## Error Detection and Correction (检错和纠错)

### 策略

1. 纠错码，使用纠错码的技术叫FEC（Forward Error Correction）
  - 在发送的数据中包含信息，让接受发推断发生了什么错误 (what)
  - 适用于容易出错的、有噪声的信道，例如无线链路
2. 检错码
  - 在发送的数据中包含信息，让接受方判断数据是否出错（is）
  - 适用于不容易出错的，例如光纤

### 两种错误模型

1. 单比特错误:极端热噪声淹没了信号
2. 突发性错误（源自物理过程）

**对比**：
- 多个单比特，如果错误是独立的，可能覆盖覆盖范围很广，导致多个数据块出错
- 突发错误一般集中在一个数据块，但是这比单个比特更难纠正

> **补充：erase channel(擦除信道):**
> 接受的模拟信号远离了0，1的预期值，相比于比特翻转，这更容易发现那个bit出错了。

### 纠错码

将冗余信息加入数据：m个数据位，r个冗余位，总共有n=m+r个位
码字：数据位和冗余位组成的序列
码率：数据位和码字的比率，m/n

- **海明距离**：两个码字之间，对应位置不同字符的个数
  - 例如：0000000000, 0000011111, 1111100000, and 1111111111
  - Hamming distance is 5，因为任意字串之间转换都需要改变5个字符
- **最小海明距离**：两个码字之间，对应位置不同字符的最小个数
- 为了检测d个错误，需要d+1的编码方案
- 为了纠正d个错误，需要2d+1的编码方案

> **例子**
> 0000000000, 0000011111, 1111100000, 1111111111, 距离为5，那么它可以纠正最多2个错误
> 比如如果是发送了0000011111，接收方收到了0000000111，发生了两个错误，那么接受发还是可以选择最接近的0000011111，从而纠正错误
> 比如如果是发送了0000000000，接收方收到了0000000111，那么它就不能正确的纠错了

校验位数量如何最少：$$m+r+1 <= 2^r$$

#### Hamming Code（海明码）

海明码能发现`多位错误`,但只能纠正`一位错误`，若用在纠正传输中出现突发性差错时可以采用下述方法:将连续P个码字排成一个矩阵，每行一个码字。如果发生突发长度≤P的突发错误，那么在P个码字中最多每个码字有一位有差错，正好由海明码能纠正。

> - **确定编码数量**：
>   - 由 $$2^r >= m+r+1$$，可以确定需要r个校验位
> - **确定每个校验位的位置**：
>   - 从1开始，2的幂次方，即1, 2, 4, 8, 16, 32, 64, 128, ...
> - 拼接校验位和数据位，得到n+r位的码字
> - **校验位的值**：
>   - 对于第i（i=1,2,3...）个校验位，从当前校验位所在位置开始（校验位初始化值为0），若用一个tmp来表示校验位的值，tmp = 0，将tmp^=码字位，并且每隔 $$2^（i-1）$$ 个位置再次异或，得到校验位的值。
>   - （校验位的值的意义就是判断这些统计的部分里的1的个数是否为奇数（tmp=1）或偶数（tmp=0））

接收方收到码字后，用同样的方法计算新的校验位的值，并将重新计算出来的校验位依次，从二进制低位到高位排列
> - 如果二进制数最终代表0，那么就没有错误
> - 否则，如果出错了一位，那么二进制所代表的数就是码字出错的位置
>   - 纠正：将计算出来的出错位置取反，得到正确的码字

### 检错码

#### Parity(奇偶校验)

- **奇校验**：校验位使得整个数据包中1的个数是奇数
- **偶校验**：校验位使得整个数据包中1的个数是偶数

![img](/专业课/计算机网络/Parity.png)

#### Checksums(校验和)

检验部位：IP头部，数据正文不参与校验计算

- **计算**：将数据包中的所有字相加，然后取反码，得`检验和`
- **校验**：将检验和与数据包中的所有字相加，然后取反码，如果结果为0，那么数据包没有错误

#### CRC (Cyclic Redundancy Check)

- **计算**: 将数据包中的所有字与生成多项式进行模2除法，得到余数，余数就是检验位
- **商定**: 生成多项式是双方商定好的，且多项式的最高位和最低位系数都是1
- **校验**: 将数据包中的所有字与生成多项式进行模2除法，得到余数，如果余数为0，那么数据包没有错误

- **生成多项式**：生成多项式是二进制数，每一位表示多项式的一项

## 基本数据链路层协议

> NIC: Network Interface Card(网络接口卡)

> 数据包和帧：网络层从传输层获得报文，加上网络层头以创建数据包，传递给链路层，链路层将数据包装在帧的info中

### 单工协议

#### 乌托邦式的单工协议

完全没有异常发生。

- **发送方** 
  - 从网络层获取数据包
  - 将数据包放入帧中
  - 向物理层发送帧
- **接收方**
  - 等待事件
  - 从物理层接收帧
  - 将帧中的数据包交给网络层


#### 无错信道的单工协议

> 考虑了发送方淹没接收方，进行了流量控制。
> 由于需要接收方反馈一个哑帧（确认），需要一个半双工信道
> 停-等式协议

- **发送方**
  - 从网络层获取数据包
  - 将数据包放入帧中
  - 向物理层发送帧
  - 等待事件（等待接收方发送回来的哑帧）
- **接收方**
  - 等待事件
  - 从物理层接收帧
  - 将帧中的数据包交给网络层
  - 发送确认帧

#### 有错信道的单工停-等式协议

> 考虑帧传输的丢失、帧传输的重复
> 计时器（发送发判断超时）、序列号（接收方区分重复）
> ARQ、PAR


- **计时器** 发送方在发送帧后启动计时器，如果计时器超时，那么就重新发送当前帧(如果仅仅是因为接收方的确认帧丢失了导致的超时，就有可能发生重复帧的情况)
- **序列号** 由于我们只关心当前帧是否达到，而决定我们下一帧是发送当前帧还是后一帧，所以用一位0/1足够区分了
  - 接受方收到重复帧和受损帧，只需要重传最后一次正确接受到的帧的序号就可以让发送新帧或者重新发送受损帧

### 双向通信的协议

> 实际情况需要双方计算机同时互相传输一些数据

- **全双工信道** 
  - 一个用来发送数据，一个用来发送确认。
  - 缺点是浪费逆向信道的带宽。
- **piggybacking(捎带确认)** 
  - 一个机器向另一个机器的数据帧和确认帧可以一起发送。
  - 优点：省带宽,并且减少了发送的帧的数量（节省了帧头）
  - 缺点：发送一个确认帧可能还需要等待本机的网络层发数据包下来
  - 缺点改进：当一段时间内确实没有数据包发下来，就发送一个单独的确认帧

#### 滑动窗口协议

**基本工作模式**

- **发送方** 
  - 窗口内代表可以发送，但是没有被发送/被确认接受的帧
  - 如果窗口大小达到上界，暂时停止从网络层接受数据包
- **接收方**
  - 窗口内代表等待接受的帧，任何落在窗口内的帧都在链路层缓存
  - 如果窗口下界刚好有已经接受了的帧，那么就把数据包解析给网络层，窗口下界+1


