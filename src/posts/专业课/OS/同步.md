# 同步 Synchronization

## 关键概念

- **进入区** Entry Section
- **临界区** Critical Section
  - 某些进程需要访问共享资源，这些进程在访问共享资源时不能被中断，否则会导致数据不一致
  - 临界区是访问共享资源的代码段
- **退出区** Exit Section
- **剩余区** Remainder Section
  - 进程在临界区外执行的代码

- **临界区三条要求**
  - 互斥：一次只有一个进程能进入临界区
  - 进步：只有不在剩余区的进程才能进入临界区
  - 有限等待：从一个进程发出进入请求到进入的这段时间内，其他进程进入临界区的次数有上限

- **两种常用于处理临界区问题的方法**
  - 抢占式内核
  - 非抢占式内核

## Peterson解决方案

两个进程需要共享的数据：
```c
int turn = 0; // 轮流标志
bool flag[2] = {0, 0}; // 进程是否想进入临界区
```

进程Pi的代码：
```c
do{
    flag[i] = true; // Pi想进入临界区
    turn = j; // 尝试让另一个进程进入临界区
    while(flag[j] && turn == j); // 等待另一个进程退出临界区
    // 临界区
    flag[i] = false; // Pi退出临界区
    // 剩余区
    
}while(true)
```

## 硬件同步

原子化地进行操作
- TestAndSet
- CompareAndSwap

## 互斥锁 Mutex Lock

> acquire() 和 release()

- 忙等待
- 自旋锁

## 信号量 Semaphore

> wait() 和 signal()

- 二进制信号量
- 计数信号量

## 死锁、饥饿、优先级反转

## 经典同步问题

### 有界缓冲（生产者-消费者）

### 读者-作者

### 哲学家就餐

## 管程

### 使用

### 哲学家就餐+管程

### 信号量+管程

### 管程进程重启

## 同步案例

### Windows

### Linux

### Solaris

### Pthreads

#### 命名信号量、匿名信号量

## 替代方法

### 事务内存

### OpenMP

### 函数式编程