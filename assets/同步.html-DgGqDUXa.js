import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as l,o as n}from"./app-B4VCe033.js";const e={};function t(h,i){return n(),a("div",null,i[0]||(i[0]=[l(`<h1 id="同步-synchronization" tabindex="-1"><a class="header-anchor" href="#同步-synchronization"><span>同步 Synchronization</span></a></h1><h2 id="关键概念" tabindex="-1"><a class="header-anchor" href="#关键概念"><span>关键概念</span></a></h2><ul><li><p><strong>进入区</strong> Entry Section</p></li><li><p><strong>临界区</strong> Critical Section</p><ul><li>某些进程需要访问共享资源，这些进程在访问共享资源时不能被中断，否则会导致数据不一致</li><li>临界区是访问共享资源的代码段</li></ul></li><li><p><strong>退出区</strong> Exit Section</p></li><li><p><strong>剩余区</strong> Remainder Section</p><ul><li>进程在临界区外执行的代码</li></ul></li><li><p><strong>临界区三条要求</strong></p><ul><li>互斥：一次只有一个进程能进入临界区</li><li>进步：只有不在剩余区的进程才能进入临界区</li><li>有限等待：从一个进程发出进入请求到进入的这段时间内，其他进程进入临界区的次数有上限</li></ul></li><li><p><strong>两种常用于处理临界区问题的方法</strong></p><ul><li>抢占式内核</li><li>非抢占式内核</li></ul></li></ul><h2 id="peterson解决方案" tabindex="-1"><a class="header-anchor" href="#peterson解决方案"><span>Peterson解决方案</span></a></h2><p>两个进程需要共享的数据：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> turn </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 轮流标志</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> flag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 进程是否想进入临界区</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>进程Pi的代码：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">do</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    flag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // Pi想进入临界区</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    turn </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 尝试让另一个进程进入临界区</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">flag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[j] </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> turn </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 等待另一个进程退出临界区</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 临界区</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    flag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // Pi退出临界区</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 剩余区</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="硬件同步" tabindex="-1"><a class="header-anchor" href="#硬件同步"><span>硬件同步</span></a></h2><p>原子化地进行操作</p><ul><li>TestAndSet</li><li>CompareAndSwap</li></ul><h2 id="互斥锁-mutex-lock" tabindex="-1"><a class="header-anchor" href="#互斥锁-mutex-lock"><span>互斥锁 Mutex Lock</span></a></h2><blockquote><p>acquire() 和 release()</p></blockquote><ul><li>忙等待</li><li>自旋锁</li></ul><h2 id="信号量-semaphore" tabindex="-1"><a class="header-anchor" href="#信号量-semaphore"><span>信号量 Semaphore</span></a></h2><blockquote><p>wait() 和 signal()</p></blockquote><ul><li>二进制信号量</li><li>计数信号量</li></ul><h2 id="死锁、饥饿、优先级反转" tabindex="-1"><a class="header-anchor" href="#死锁、饥饿、优先级反转"><span>死锁、饥饿、优先级反转</span></a></h2><h2 id="经典同步问题" tabindex="-1"><a class="header-anchor" href="#经典同步问题"><span>经典同步问题</span></a></h2><h3 id="有界缓冲-生产者-消费者" tabindex="-1"><a class="header-anchor" href="#有界缓冲-生产者-消费者"><span>有界缓冲（生产者-消费者）</span></a></h3><h3 id="读者-作者" tabindex="-1"><a class="header-anchor" href="#读者-作者"><span>读者-作者</span></a></h3><h3 id="哲学家就餐" tabindex="-1"><a class="header-anchor" href="#哲学家就餐"><span>哲学家就餐</span></a></h3><h2 id="管程" tabindex="-1"><a class="header-anchor" href="#管程"><span>管程</span></a></h2><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><h3 id="哲学家就餐-管程" tabindex="-1"><a class="header-anchor" href="#哲学家就餐-管程"><span>哲学家就餐+管程</span></a></h3><h3 id="信号量-管程" tabindex="-1"><a class="header-anchor" href="#信号量-管程"><span>信号量+管程</span></a></h3><h3 id="管程进程重启" tabindex="-1"><a class="header-anchor" href="#管程进程重启"><span>管程进程重启</span></a></h3><h2 id="同步案例" tabindex="-1"><a class="header-anchor" href="#同步案例"><span>同步案例</span></a></h2><h3 id="windows" tabindex="-1"><a class="header-anchor" href="#windows"><span>Windows</span></a></h3><h3 id="linux" tabindex="-1"><a class="header-anchor" href="#linux"><span>Linux</span></a></h3><h3 id="solaris" tabindex="-1"><a class="header-anchor" href="#solaris"><span>Solaris</span></a></h3><h3 id="pthreads" tabindex="-1"><a class="header-anchor" href="#pthreads"><span>Pthreads</span></a></h3><h4 id="命名信号量、匿名信号量" tabindex="-1"><a class="header-anchor" href="#命名信号量、匿名信号量"><span>命名信号量、匿名信号量</span></a></h4><h2 id="替代方法" tabindex="-1"><a class="header-anchor" href="#替代方法"><span>替代方法</span></a></h2><h3 id="事务内存" tabindex="-1"><a class="header-anchor" href="#事务内存"><span>事务内存</span></a></h3><h3 id="openmp" tabindex="-1"><a class="header-anchor" href="#openmp"><span>OpenMP</span></a></h3><h3 id="函数式编程" tabindex="-1"><a class="header-anchor" href="#函数式编程"><span>函数式编程</span></a></h3>`,37)]))}const d=s(e,[["render",t],["__file","同步.html.vue"]]),k=JSON.parse('{"path":"/posts/%E4%B8%93%E4%B8%9A%E8%AF%BE/OS/%E5%90%8C%E6%AD%A5.html","title":"同步 Synchronization","lang":"zh-CN","frontmatter":{"description":"同步 Synchronization 关键概念 进入区 Entry Section 临界区 Critical Section 某些进程需要访问共享资源，这些进程在访问共享资源时不能被中断，否则会导致数据不一致 临界区是访问共享资源的代码段 退出区 Exit Section 剩余区 Remainder Section 进程在临界区外执行的代码 临界区三条...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/%E4%B8%93%E4%B8%9A%E8%AF%BE/OS/%E5%90%8C%E6%AD%A5.html"}],["meta",{"property":"og:site_name","content":"DayDreamer的个人博客"}],["meta",{"property":"og:title","content":"同步 Synchronization"}],["meta",{"property":"og:description","content":"同步 Synchronization 关键概念 进入区 Entry Section 临界区 Critical Section 某些进程需要访问共享资源，这些进程在访问共享资源时不能被中断，否则会导致数据不一致 临界区是访问共享资源的代码段 退出区 Exit Section 剩余区 Remainder Section 进程在临界区外执行的代码 临界区三条..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"同步 Synchronization\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DayDreamer\\",\\"url\\":\\"https://floatDreamWithSong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"关键概念","slug":"关键概念","link":"#关键概念","children":[]},{"level":2,"title":"Peterson解决方案","slug":"peterson解决方案","link":"#peterson解决方案","children":[]},{"level":2,"title":"硬件同步","slug":"硬件同步","link":"#硬件同步","children":[]},{"level":2,"title":"互斥锁 Mutex Lock","slug":"互斥锁-mutex-lock","link":"#互斥锁-mutex-lock","children":[]},{"level":2,"title":"信号量 Semaphore","slug":"信号量-semaphore","link":"#信号量-semaphore","children":[]},{"level":2,"title":"死锁、饥饿、优先级反转","slug":"死锁、饥饿、优先级反转","link":"#死锁、饥饿、优先级反转","children":[]},{"level":2,"title":"经典同步问题","slug":"经典同步问题","link":"#经典同步问题","children":[{"level":3,"title":"有界缓冲（生产者-消费者）","slug":"有界缓冲-生产者-消费者","link":"#有界缓冲-生产者-消费者","children":[]},{"level":3,"title":"读者-作者","slug":"读者-作者","link":"#读者-作者","children":[]},{"level":3,"title":"哲学家就餐","slug":"哲学家就餐","link":"#哲学家就餐","children":[]}]},{"level":2,"title":"管程","slug":"管程","link":"#管程","children":[{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":3,"title":"哲学家就餐+管程","slug":"哲学家就餐-管程","link":"#哲学家就餐-管程","children":[]},{"level":3,"title":"信号量+管程","slug":"信号量-管程","link":"#信号量-管程","children":[]},{"level":3,"title":"管程进程重启","slug":"管程进程重启","link":"#管程进程重启","children":[]}]},{"level":2,"title":"同步案例","slug":"同步案例","link":"#同步案例","children":[{"level":3,"title":"Windows","slug":"windows","link":"#windows","children":[]},{"level":3,"title":"Linux","slug":"linux","link":"#linux","children":[]},{"level":3,"title":"Solaris","slug":"solaris","link":"#solaris","children":[]},{"level":3,"title":"Pthreads","slug":"pthreads","link":"#pthreads","children":[]}]},{"level":2,"title":"替代方法","slug":"替代方法","link":"#替代方法","children":[{"level":3,"title":"事务内存","slug":"事务内存","link":"#事务内存","children":[]},{"level":3,"title":"OpenMP","slug":"openmp","link":"#openmp","children":[]},{"level":3,"title":"函数式编程","slug":"函数式编程","link":"#函数式编程","children":[]}]}],"readingTime":{"minutes":1.49,"words":447},"filePathRelative":"posts/专业课/OS/同步.md","excerpt":"\\n<h2>关键概念</h2>\\n<ul>\\n<li>\\n<p><strong>进入区</strong> Entry Section</p>\\n</li>\\n<li>\\n<p><strong>临界区</strong> Critical Section</p>\\n<ul>\\n<li>某些进程需要访问共享资源，这些进程在访问共享资源时不能被中断，否则会导致数据不一致</li>\\n<li>临界区是访问共享资源的代码段</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>退出区</strong> Exit Section</p>\\n</li>\\n<li>\\n<p><strong>剩余区</strong> Remainder Section</p>\\n<ul>\\n<li>进程在临界区外执行的代码</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>临界区三条要求</strong></p>\\n<ul>\\n<li>互斥：一次只有一个进程能进入临界区</li>\\n<li>进步：只有不在剩余区的进程才能进入临界区</li>\\n<li>有限等待：从一个进程发出进入请求到进入的这段时间内，其他进程进入临界区的次数有上限</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>两种常用于处理临界区问题的方法</strong></p>\\n<ul>\\n<li>抢占式内核</li>\\n<li>非抢占式内核</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{d as comp,k as data};
