import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as o,o as n}from"./app-CREM1zrg.js";const a="/%E4%B8%93%E4%B8%9A%E8%AF%BE/OS/%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80%E4%BF%9D%E6%8A%A4.png",r="/%E4%B8%93%E4%B8%9A%E8%AF%BE/OS/bind.png",l={};function s(c,e){return n(),i("div",null,e[0]||(e[0]=[o('<h1 id="内存管理策略" tabindex="-1"><a class="header-anchor" href="#内存管理策略"><span>内存管理策略</span></a></h1><h2 id="进程的内存空间" tabindex="-1"><a class="header-anchor" href="#进程的内存空间"><span>进程的内存空间</span></a></h2><p>进程需要单独的进程空间以避免受到影响，需要<code>基址地址寄存器</code>和<code>界限地址寄存器</code>，来记录每个进程的内存范围。</p><p>由于进程切换时，地址寄存器的值也会保存在PCB中，因此并不需要多个这类寄存器。</p><blockquote><p><code>基址地址寄存器</code>记录了最小的合法物理内存地址 <code>界限地址寄存器</code>记录了内存范围的大小</p></blockquote><h3 id="硬件地址保护" tabindex="-1"><a class="header-anchor" href="#硬件地址保护"><span>硬件地址保护</span></a></h3><figure><img src="'+a+'" alt="硬件地址保护" tabindex="0" loading="lazy"><figcaption>硬件地址保护</figcaption></figure><h3 id="地址绑定" tabindex="-1"><a class="header-anchor" href="#地址绑定"><span>地址绑定</span></a></h3><p>可执行文件的指令、数据等需要放在内存空间中，因此需要为它们绑定访问到它们的地址</p><figure><img src="'+r+'" alt="bind" tabindex="0" loading="lazy"><figcaption>bind</figcaption></figure><p>根据需求选择不同的bind方法</p><ul><li><strong>compile time</strong>：编译时就知道要放在哪里，生成<code>绝对地址（absolute code）</code>，例如烧写单片机等板子上的程序</li><li><strong>load time</strong>：编译时不知道运行在哪，生成<code>可重定位代码（relocatable code）</code>，在加载程序到内存时才开始bind</li><li><strong>runtime time</strong>：运行时进程可以在内存中转移到另一块区域时</li></ul><h3 id="逻辑地址-空间、物理地址-空间" tabindex="-1"><a class="header-anchor" href="#逻辑地址-空间、物理地址-空间"><span>逻辑地址 空间、物理地址 空间</span></a></h3><h2 id="名词解释" tabindex="-1"><a class="header-anchor" href="#名词解释"><span>名词解释</span></a></h2><ul><li><strong>stall</strong> ：暂停。CPU执行依赖于没有现行数据的指令时，需要等待内存访问以获得数据。</li><li><strong>cache</strong> ：高速缓存。</li><li><strong>base register、limit register</strong> ：基址地址寄存器、界限地址寄存器。</li><li><strong>memory-address registry</strong>：内存地址寄存器。</li><li><strong>logic address、physical address</strong>：逻辑地址（CPU生成）、物理地址（常加载到内存地址寄存器中）</li><li><strong>virtual address</strong>：虚拟地址。执行时地址bind方案会生成不同的逻辑地址和物理地址，在这种情况下，逻辑地址称为虚拟地址。</li></ul>',15)]))}const g=t(l,[["render",s],["__file","内存管理.html.vue"]]),h=JSON.parse('{"path":"/posts/%E4%B8%93%E4%B8%9A%E8%AF%BE/OS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"内存管理策略","lang":"zh-CN","frontmatter":{"description":"内存管理策略 进程的内存空间 进程需要单独的进程空间以避免受到影响，需要基址地址寄存器和界限地址寄存器，来记录每个进程的内存范围。 由于进程切换时，地址寄存器的值也会保存在PCB中，因此并不需要多个这类寄存器。 基址地址寄存器记录了最小的合法物理内存地址 界限地址寄存器记录了内存范围的大小 硬件地址保护 硬件地址保护硬件地址保护 地址绑定 可执行文件的...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/%E4%B8%93%E4%B8%9A%E8%AF%BE/OS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"DayDreamer的个人博客"}],["meta",{"property":"og:title","content":"内存管理策略"}],["meta",{"property":"og:description","content":"内存管理策略 进程的内存空间 进程需要单独的进程空间以避免受到影响，需要基址地址寄存器和界限地址寄存器，来记录每个进程的内存范围。 由于进程切换时，地址寄存器的值也会保存在PCB中，因此并不需要多个这类寄存器。 基址地址寄存器记录了最小的合法物理内存地址 界限地址寄存器记录了内存范围的大小 硬件地址保护 硬件地址保护硬件地址保护 地址绑定 可执行文件的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/专业课/OS/硬件地址保护.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存管理策略\\",\\"image\\":[\\"https://mister-hope.github.io/专业课/OS/硬件地址保护.png\\",\\"https://mister-hope.github.io/专业课/OS/bind.png\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DayDreamer\\",\\"url\\":\\"https://floatDreamWithSong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"进程的内存空间","slug":"进程的内存空间","link":"#进程的内存空间","children":[{"level":3,"title":"硬件地址保护","slug":"硬件地址保护","link":"#硬件地址保护","children":[]},{"level":3,"title":"地址绑定","slug":"地址绑定","link":"#地址绑定","children":[]},{"level":3,"title":"逻辑地址 空间、物理地址 空间","slug":"逻辑地址-空间、物理地址-空间","link":"#逻辑地址-空间、物理地址-空间","children":[]}]},{"level":2,"title":"名词解释","slug":"名词解释","link":"#名词解释","children":[]}],"readingTime":{"minutes":1.53,"words":460},"filePathRelative":"posts/专业课/OS/内存管理.md","excerpt":"\\n<h2>进程的内存空间</h2>\\n<p>进程需要单独的进程空间以避免受到影响，需要<code>基址地址寄存器</code>和<code>界限地址寄存器</code>，来记录每个进程的内存范围。</p>\\n<p>由于进程切换时，地址寄存器的值也会保存在PCB中，因此并不需要多个这类寄存器。</p>\\n<blockquote>\\n<p><code>基址地址寄存器</code>记录了最小的合法物理内存地址\\n<code>界限地址寄存器</code>记录了内存范围的大小</p>\\n</blockquote>\\n<h3>硬件地址保护</h3>\\n<figure><img src=\\"/专业课/OS/硬件地址保护.png\\" alt=\\"硬件地址保护\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>硬件地址保护</figcaption></figure>","autoDesc":true}');export{g as comp,h as data};
