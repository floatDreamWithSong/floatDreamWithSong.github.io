import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as p,o as e}from"./app-B7nswRip.js";const t={};function r(o,l){return e(),n("div",null,l[0]||(l[0]=[p('<h1 id="手写编译解释器的零碎笔记" tabindex="-1"><a class="header-anchor" href="#手写编译解释器的零碎笔记"><span>手写编译解释器的零碎笔记</span></a></h1><ul><li><p>扫描（词法分析）：将源代码转换成一个个的词法单元（token）</p></li><li><p>解析词法分析结果生成抽象语法树（语法分析）</p></li><li><p>静态分析 -<code> 绑定或决议</code>:对于每一个标识符，我们都要找出定义该名称的地方，并将两者连接起来。这就是作用域的作用——在这个源代码区域中，某个名字可以用来引用某个声明。如果语言是静态类型的，这就是我们进行类型检查的时机</p></li><li><p>中间码（字节码）（intermediate representation， 也叫IR）</p></li><li><p>中间码是介于源代码和目标代码之间的代码。它比源代码更接近目标代码，但仍然与具体的机器无关。中间码使得编译器可以生成与机器无关的代码，从而在不同的机器上运行。中间码还可以用于优化和调试。</p></li><li><p>优化中间代码</p><ul><li>比如用户输入了一串字面量计算表达式，我们可以直接把结果计算出来放入程序</li></ul></li><li><p>生成目标代码</p></li><li><p>虚拟机</p></li><li><p>运行时</p><ul><li>GC</li><li>反射</li></ul></li><li><p>编译器</p><ul><li>单遍编译器 <ul><li>一些简单的编译器将解析、分析和代码生成交织在一起，这样它们就可以直接在解析器中生成输出代码，而无需分配任何语法树或其他IR。比如C和骆驼</li><li>你没有中间数据结构来存储程序的全局信息，也不会重新访问任何之前解析过的代码部分。</li></ul></li><li>树遍历解释器 <ul><li>有些编程语言在将代码解析为AST后就开始执行代码（可能应用了一点静态分析）。为了运行程序，解释器每次都会遍历语法树的一个分支和叶子，并在运行过程中计算每个节点。</li></ul></li><li>转译器 <ul><li>转译器将源代码转换为另一种语言的代码，然后使用该语言的编译器或解释器来运行生成的代码。比如TypeScript</li></ul></li><li>JIT（Just-In-Time）编译器 <ul><li>JIT编译器在运行时将中间代码转换为机器代码。JIT编译器通常用于提高性能，因为它们可以在运行时进行优化，而无需在编译时进行优化。JIT编译器通常用于高性能应用，如游戏和Web浏览器。</li></ul></li><li>AOT（Ahead-Of-Time）编译器 <ul><li>AOT编译器在编译时将源代码转换为机器代码。AOT编译器通常用于提高性能，因为它们可以在编译时进行优化，而无需在运行时进行优化。AOT编译器通常用于高性能应用，如操作系统和嵌入式系统。</li></ul></li></ul></li><li><p>动态类型</p></li><li><p>自动内存管理，GC：引用计数和依赖跟踪</p></li><li><p>数据类型</p><ul><li>布尔</li><li>数字</li><li>字符串</li></ul></li><li><p>表达式</p><ul><li>算术运算</li><li>比较运算</li><li>逻辑运算</li><li>（优先级）</li></ul></li><li><p>语句</p></li><li><p>变量</p></li><li><p>控制流</p><ul><li>分支</li><li>循环</li></ul></li><li><p>函数</p></li><li><p>闭包</p></li><li><p>类 or 原型</p></li><li><p>词素和标记（Lexemes and Tokens）:词法单元</p></li><li><p>标记类型</p></li><li><p>CFG：上下文无关语法（Context-Free Grammar）</p></li><li><p>表达式类</p></li><li><p>Metaprogramming the trees：树形元编程</p></li><li><p>访问者模式</p></li><li><p>递归下降解析器</p></li></ul>',2)]))}const s=i(t,[["render",r],["__file","业余零碎笔记.html.vue"]]),m=JSON.parse('{"path":"/posts/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E4%B8%9A%E4%BD%99%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0.html","title":"手写编译解释器的零碎笔记","lang":"zh-CN","frontmatter":{"description":"手写编译解释器的零碎笔记 扫描（词法分析）：将源代码转换成一个个的词法单元（token） 解析词法分析结果生成抽象语法树（语法分析） 静态分析 - 绑定或决议:对于每一个标识符，我们都要找出定义该名称的地方，并将两者连接起来。这就是作用域的作用——在这个源代码区域中，某个名字可以用来引用某个声明。如果语言是静态类型的，这就是我们进行类型检查的时机 中间...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E4%B8%9A%E4%BD%99%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0.html"}],["meta",{"property":"og:site_name","content":"DayDreamer的个人博客"}],["meta",{"property":"og:title","content":"手写编译解释器的零碎笔记"}],["meta",{"property":"og:description","content":"手写编译解释器的零碎笔记 扫描（词法分析）：将源代码转换成一个个的词法单元（token） 解析词法分析结果生成抽象语法树（语法分析） 静态分析 - 绑定或决议:对于每一个标识符，我们都要找出定义该名称的地方，并将两者连接起来。这就是作用域的作用——在这个源代码区域中，某个名字可以用来引用某个声明。如果语言是静态类型的，这就是我们进行类型检查的时机 中间..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"手写编译解释器的零碎笔记\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DayDreamer\\",\\"url\\":\\"https://floatDreamWithSong.github.io\\"}]}"]]},"headers":[],"readingTime":{"minutes":2.75,"words":825},"filePathRelative":"posts/专业课/编译原理/业余零碎笔记.md","excerpt":"\\n<ul>\\n<li>\\n<p>扫描（词法分析）：将源代码转换成一个个的词法单元（token）</p>\\n</li>\\n<li>\\n<p>解析词法分析结果生成抽象语法树（语法分析）</p>\\n</li>\\n<li>\\n<p>静态分析\\n-<code> 绑定或决议</code>:对于每一个标识符，我们都要找出定义该名称的地方，并将两者连接起来。这就是作用域的作用——在这个源代码区域中，某个名字可以用来引用某个声明。如果语言是静态类型的，这就是我们进行类型检查的时机</p>\\n</li>\\n<li>\\n<p>中间码（字节码）（intermediate representation， 也叫IR）</p>\\n</li>\\n<li>\\n<p>中间码是介于源代码和目标代码之间的代码。它比源代码更接近目标代码，但仍然与具体的机器无关。中间码使得编译器可以生成与机器无关的代码，从而在不同的机器上运行。中间码还可以用于优化和调试。</p>\\n</li>\\n<li>\\n<p>优化中间代码</p>\\n<ul>\\n<li>比如用户输入了一串字面量计算表达式，我们可以直接把结果计算出来放入程序</li>\\n</ul>\\n</li>\\n<li>\\n<p>生成目标代码</p>\\n</li>\\n<li>\\n<p>虚拟机</p>\\n</li>\\n<li>\\n<p>运行时</p>\\n<ul>\\n<li>GC</li>\\n<li>反射</li>\\n</ul>\\n</li>\\n<li>\\n<p>编译器</p>\\n<ul>\\n<li>单遍编译器\\n<ul>\\n<li>一些简单的编译器将解析、分析和代码生成交织在一起，这样它们就可以直接在解析器中生成输出代码，而无需分配任何语法树或其他IR。比如C和骆驼</li>\\n<li>你没有中间数据结构来存储程序的全局信息，也不会重新访问任何之前解析过的代码部分。</li>\\n</ul>\\n</li>\\n<li>树遍历解释器\\n<ul>\\n<li>有些编程语言在将代码解析为AST后就开始执行代码（可能应用了一点静态分析）。为了运行程序，解释器每次都会遍历语法树的一个分支和叶子，并在运行过程中计算每个节点。</li>\\n</ul>\\n</li>\\n<li>转译器\\n<ul>\\n<li>转译器将源代码转换为另一种语言的代码，然后使用该语言的编译器或解释器来运行生成的代码。比如TypeScript</li>\\n</ul>\\n</li>\\n<li>JIT（Just-In-Time）编译器\\n<ul>\\n<li>JIT编译器在运行时将中间代码转换为机器代码。JIT编译器通常用于提高性能，因为它们可以在运行时进行优化，而无需在编译时进行优化。JIT编译器通常用于高性能应用，如游戏和Web浏览器。</li>\\n</ul>\\n</li>\\n<li>AOT（Ahead-Of-Time）编译器\\n<ul>\\n<li>AOT编译器在编译时将源代码转换为机器代码。AOT编译器通常用于提高性能，因为它们可以在编译时进行优化，而无需在运行时进行优化。AOT编译器通常用于高性能应用，如操作系统和嵌入式系统。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>动态类型</p>\\n</li>\\n<li>\\n<p>自动内存管理，GC：引用计数和依赖跟踪</p>\\n</li>\\n<li>\\n<p>数据类型</p>\\n<ul>\\n<li>布尔</li>\\n<li>数字</li>\\n<li>字符串</li>\\n</ul>\\n</li>\\n<li>\\n<p>表达式</p>\\n<ul>\\n<li>算术运算</li>\\n<li>比较运算</li>\\n<li>逻辑运算</li>\\n<li>（优先级）</li>\\n</ul>\\n</li>\\n<li>\\n<p>语句</p>\\n</li>\\n<li>\\n<p>变量</p>\\n</li>\\n<li>\\n<p>控制流</p>\\n<ul>\\n<li>分支</li>\\n<li>循环</li>\\n</ul>\\n</li>\\n<li>\\n<p>函数</p>\\n</li>\\n<li>\\n<p>闭包</p>\\n</li>\\n<li>\\n<p>类 or 原型</p>\\n</li>\\n<li>\\n<p>词素和标记（Lexemes and Tokens）:词法单元</p>\\n</li>\\n<li>\\n<p>标记类型</p>\\n</li>\\n<li>\\n<p>CFG：上下文无关语法（Context-Free Grammar）</p>\\n</li>\\n<li>\\n<p>表达式类</p>\\n</li>\\n<li>\\n<p>Metaprogramming the trees：树形元编程</p>\\n</li>\\n<li>\\n<p>访问者模式</p>\\n</li>\\n<li>\\n<p>递归下降解析器</p>\\n</li>\\n</ul>","autoDesc":true}');export{s as comp,m as data};
