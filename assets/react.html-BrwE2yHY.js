import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as i,o as t}from"./app-DkCAg-b7.js";const n={};function l(r,e){return t(),a("div",null,e[0]||(e[0]=[i(`<h1 id="react" tabindex="-1"><a class="header-anchor" href="#react"><span>React</span></a></h1><p>React是一个很有哲学意味的框架，它的很多运行机制都体现了“纯粹”的理念。</p><h2 id="useref" tabindex="-1"><a class="header-anchor" href="#useref"><span>useRef</span></a></h2><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h3><p><code>ref</code>是一个脱围机制，避免React检测到它的变化，从而避免不必要的渲染。同时又不像普通变量在重渲染时被重置。</p><h3 id="用法" tabindex="-1"><a class="header-anchor" href="#用法"><span>用法</span></a></h3><p>通过<code>useRef</code>创建一个ref对象，通过<code>ref.current</code>访问该对象。</p><p>还可以操作DOM节点，需要在JSX上使用<code>ref</code>属性来指定。</p><h3 id="解决" tabindex="-1"><a class="header-anchor" href="#解决"><span>解决</span></a></h3><p>如果是自定义的组件，可以通过<code>forwardRef</code>来传递ref。暴露DOM对象时可以通过<code>useImperativeHandle</code>来只暴露必要的属性、事件等。</p><h2 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect"><span>useEffect</span></a></h2><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 回调函数</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 这里的处理逻辑应该是副作用，是由于组件渲染了才需要额外执行的同步策略，比如数据获取、订阅或者手动更改DOM，</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 而不是由特定交互事件引起的，</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 自定义清理函数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, [依赖项, </span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="运行机制" tabindex="-1"><a class="header-anchor" href="#运行机制"><span>运行机制</span></a></h3><p>在组件渲染到屏幕之后执行<code>useEffect</code>的回调函数，React 会在 Effect 再次运行之前和在组件卸载时调用你的清理函数。</p><p>依赖项是可选的，如果依赖项发生变化，则重新执行<code>useEffect</code>的回调函数。</p><p>如果依赖项为空数组，则只在组件首次渲染后执行一次。</p><p>对于<code>ref</code>类型的依赖项，React不会检测它的变化，因为它是脱围机制。</p><h3 id="开发时特性" tabindex="-1"><a class="header-anchor" href="#开发时特性"><span>开发时特性</span></a></h3><p>React在开发环境下，会装载两次，卸载一次以自动测试组件的渲染和卸载。这有利于你检查组件卸载时是否正确地清理了Effect。</p><h3 id="陷阱" tabindex="-1"><a class="header-anchor" href="#陷阱"><span>陷阱</span></a></h3><p>禁止在<code>useEffect</code>的回调函数中直接修改<code>state</code>，因为每次修改<code>state</code>都会触发组件的重新渲染，而重新渲染又会触发<code>useEffect</code>的回调函数，从而形成无限循环。</p><p><a href="https://zh-hans.react.dev/learn/you-might-not-need-an-effect" target="_blank" rel="noopener noreferrer">你可能不需要Effect</a></p>`,23)]))}const d=s(n,[["render",l],["__file","react.html.vue"]]),p=JSON.parse('{"path":"/posts/react/react.html","title":"React","lang":"zh-CN","frontmatter":{"description":"React React是一个很有哲学意味的框架，它的很多运行机制都体现了“纯粹”的理念。 useRef 特点 ref是一个脱围机制，避免React检测到它的变化，从而避免不必要的渲染。同时又不像普通变量在重渲染时被重置。 用法 通过useRef创建一个ref对象，通过ref.current访问该对象。 还可以操作DOM节点，需要在JSX上使用ref属性...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/react/react.html"}],["meta",{"property":"og:site_name","content":"DayDreamer的个人博客"}],["meta",{"property":"og:title","content":"React"}],["meta",{"property":"og:description","content":"React React是一个很有哲学意味的框架，它的很多运行机制都体现了“纯粹”的理念。 useRef 特点 ref是一个脱围机制，避免React检测到它的变化，从而避免不必要的渲染。同时又不像普通变量在重渲染时被重置。 用法 通过useRef创建一个ref对象，通过ref.current访问该对象。 还可以操作DOM节点，需要在JSX上使用ref属性..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DayDreamer\\",\\"url\\":\\"https://floatDreamWithSong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"useRef","slug":"useref","link":"#useref","children":[{"level":3,"title":"特点","slug":"特点","link":"#特点","children":[]},{"level":3,"title":"用法","slug":"用法","link":"#用法","children":[]},{"level":3,"title":"解决","slug":"解决","link":"#解决","children":[]}]},{"level":2,"title":"useEffect","slug":"useeffect","link":"#useeffect","children":[{"level":3,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":3,"title":"运行机制","slug":"运行机制","link":"#运行机制","children":[]},{"level":3,"title":"开发时特性","slug":"开发时特性","link":"#开发时特性","children":[]},{"level":3,"title":"陷阱","slug":"陷阱","link":"#陷阱","children":[]}]}],"readingTime":{"minutes":1.67,"words":500},"filePathRelative":"posts/react/react.md","excerpt":"\\n<p>React是一个很有哲学意味的框架，它的很多运行机制都体现了“纯粹”的理念。</p>\\n<h2>useRef</h2>\\n<h3>特点</h3>\\n<p><code>ref</code>是一个脱围机制，避免React检测到它的变化，从而避免不必要的渲染。同时又不像普通变量在重渲染时被重置。</p>\\n<h3>用法</h3>\\n<p>通过<code>useRef</code>创建一个ref对象，通过<code>ref.current</code>访问该对象。</p>\\n<p>还可以操作DOM节点，需要在JSX上使用<code>ref</code>属性来指定。</p>\\n<h3>解决</h3>\\n<p>如果是自定义的组件，可以通过<code>forwardRef</code>来传递ref。暴露DOM对象时可以通过<code>useImperativeHandle</code>来只暴露必要的属性、事件等。</p>","autoDesc":true}');export{d as comp,p as data};
