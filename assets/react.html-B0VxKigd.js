import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as a,o as t}from"./app-B--kDasu.js";const l={};function n(h,e){return t(),i("div",null,e[0]||(e[0]=[a(`<h1 id="react" tabindex="-1"><a class="header-anchor" href="#react"><span>React</span></a></h1><p>React是一个很有哲学意味的框架，它的很多运行机制都体现了“纯粹”的理念。</p><h2 id="useref" tabindex="-1"><a class="header-anchor" href="#useref"><span>useRef</span></a></h2><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h3><p><code>ref</code>是一个脱围机制，避免React检测到它的变化，从而避免不必要的渲染。同时又不像普通变量在重渲染时被重置。</p><h3 id="用法" tabindex="-1"><a class="header-anchor" href="#用法"><span>用法</span></a></h3><p>通过<code>useRef</code>创建一个ref对象，通过<code>ref.current</code>访问该对象。</p><p>还可以操作DOM节点，需要在JSX上使用<code>ref</code>属性来指定。</p><h3 id="解决" tabindex="-1"><a class="header-anchor" href="#解决"><span>解决</span></a></h3><p>如果是自定义的组件，可以通过<code>forwardRef</code>来传递ref。暴露DOM对象时可以通过<code>useImperativeHandle</code>来只暴露必要的属性、事件等。</p><h2 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect"><span>useEffect</span></a></h2><h3 id="结构" tabindex="-1"><a class="header-anchor" href="#结构"><span>结构</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 回调函数</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 这里的处理逻辑应该是副作用，是由于组件渲染了才需要额外执行的同步策略，比如数据获取、订阅或者手动更改DOM，</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 而不是由特定交互事件引起的，</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 自定义清理函数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, [依赖项, </span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="运行机制" tabindex="-1"><a class="header-anchor" href="#运行机制"><span>运行机制</span></a></h3><p>在组件渲染到屏幕之后执行<code>useEffect</code>的回调函数，React 会在 Effect 再次运行之前和在组件卸载时调用你的清理函数。</p><p>依赖项是可选的，如果依赖项发生变化，则重新执行<code>useEffect</code>的回调函数。</p><p>如果依赖项为空数组，则只在组件首次渲染后执行一次。</p><p>对于<code>ref</code>类型的依赖项，React不会检测它的变化，因为它是脱围机制。</p><h3 id="开发时特性" tabindex="-1"><a class="header-anchor" href="#开发时特性"><span>开发时特性</span></a></h3><p>React在开发环境下，会装载两次，卸载一次以自动测试组件的渲染和卸载。这有利于你检查组件卸载时是否正确地清理了Effect。</p><h3 id="陷阱" tabindex="-1"><a class="header-anchor" href="#陷阱"><span>陷阱</span></a></h3><p>禁止在<code>useEffect</code>的回调函数中直接修改<code>state</code>，因为每次修改<code>state</code>都会触发组件的重新渲染，而重新渲染又会触发<code>useEffect</code>的回调函数，从而形成无限循环。</p><p><a href="https://zh-hans.react.dev/learn/you-might-not-need-an-effect" target="_blank" rel="noopener noreferrer">你可能不需要Effect</a></p><h2 id="usereducer" tabindex="-1"><a class="header-anchor" href="#usereducer"><span>useReducer</span></a></h2><h3 id="特点-1" tabindex="-1"><a class="header-anchor" href="#特点-1"><span>特点</span></a></h3><p><code>useReducer</code>是<code>useState</code>的替代方案，相比<code>useState</code>，它更体现了一种<code>集中管理</code>、<code>纯函数</code>，将事件处理与状态管理分离开来的策略。</p><h3 id="用法-1" tabindex="-1"><a class="header-anchor" href="#用法-1"><span>用法</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">dispatch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useReducer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">reducer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">initState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>reducer</code>是一个纯函数，用于计算新的状态。</p><p><code>dispatch</code>是一个函数，用于触发<code>reducer</code>，它的派发对象将作为<code>reducer</code>的第二个参数。</p><p><code>reducer</code>的返回值将作为新的状态。</p><p><code>reducer</code>函数：</p><div class="language-tsx line-numbers-mode" data-highlighter="shiki" data-ext="tsx" data-title="tsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">reducer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">action</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> newState</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>state</code>是当前的状态，<code>action</code>是派发对象，<code>newState</code>是新的状态。</p><h2 id="usememo" tabindex="-1"><a class="header-anchor" href="#usememo"><span>useMemo</span></a></h2><h3 id="特点-2" tabindex="-1"><a class="header-anchor" href="#特点-2"><span>特点</span></a></h3><p><code>useMemo</code>是<code>useCallback</code>的替代方案，相比<code>useCallback</code>，它更体现了一种<code>缓存</code>、<code>纯函数</code>，将事件处理与状态管理分离开来的策略。</p><h3 id="用法-2" tabindex="-1"><a class="header-anchor" href="#用法-2"><span>用法</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> memoizedValue</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useMemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> computeExpensiveValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), [</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback"><span>useCallback</span></a></h2><h3 id="特点-3" tabindex="-1"><a class="header-anchor" href="#特点-3"><span>特点</span></a></h3><p><code>useCallback</code>是<code>useMemo</code>的替代方案，相比<code>useMemo</code>，它更体现了一种<code>缓存</code>、<code>纯函数</code>，将事件处理与状态管理分离开来的策略。</p><h3 id="用法-3" tabindex="-1"><a class="header-anchor" href="#用法-3"><span>用法</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> memoizedCallback</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useCallback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  doSomething</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, [</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="memo" tabindex="-1"><a class="header-anchor" href="#memo"><span>memo</span></a></h2><h3 id="特点-4" tabindex="-1"><a class="header-anchor" href="#特点-4"><span>特点</span></a></h3><p><code>memo</code>是<code>useMemo</code>的替代方案，相比<code>useMemo</code>，它更体现了一种<code>缓存</code>、<code>纯函数</code>，将事件处理与状态管理分离开来的策略。</p><h3 id="用法-4" tabindex="-1"><a class="header-anchor" href="#用法-4"><span>用法</span></a></h3><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> MemoizedComponent</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> memo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Component</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">areEqual</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,49)]))}const c=s(l,[["render",n],["__file","react.html.vue"]]),p=JSON.parse('{"path":"/posts/react/react.html","title":"React","lang":"zh-CN","frontmatter":{"description":"React React是一个很有哲学意味的框架，它的很多运行机制都体现了“纯粹”的理念。 useRef 特点 ref是一个脱围机制，避免React检测到它的变化，从而避免不必要的渲染。同时又不像普通变量在重渲染时被重置。 用法 通过useRef创建一个ref对象，通过ref.current访问该对象。 还可以操作DOM节点，需要在JSX上使用ref属性...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/react/react.html"}],["meta",{"property":"og:site_name","content":"DayDreamer的个人博客"}],["meta",{"property":"og:title","content":"React"}],["meta",{"property":"og:description","content":"React React是一个很有哲学意味的框架，它的很多运行机制都体现了“纯粹”的理念。 useRef 特点 ref是一个脱围机制，避免React检测到它的变化，从而避免不必要的渲染。同时又不像普通变量在重渲染时被重置。 用法 通过useRef创建一个ref对象，通过ref.current访问该对象。 还可以操作DOM节点，需要在JSX上使用ref属性..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DayDreamer\\",\\"url\\":\\"https://floatDreamWithSong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"useRef","slug":"useref","link":"#useref","children":[{"level":3,"title":"特点","slug":"特点","link":"#特点","children":[]},{"level":3,"title":"用法","slug":"用法","link":"#用法","children":[]},{"level":3,"title":"解决","slug":"解决","link":"#解决","children":[]}]},{"level":2,"title":"useEffect","slug":"useeffect","link":"#useeffect","children":[{"level":3,"title":"结构","slug":"结构","link":"#结构","children":[]},{"level":3,"title":"运行机制","slug":"运行机制","link":"#运行机制","children":[]},{"level":3,"title":"开发时特性","slug":"开发时特性","link":"#开发时特性","children":[]},{"level":3,"title":"陷阱","slug":"陷阱","link":"#陷阱","children":[]}]},{"level":2,"title":"useReducer","slug":"usereducer","link":"#usereducer","children":[{"level":3,"title":"特点","slug":"特点-1","link":"#特点-1","children":[]},{"level":3,"title":"用法","slug":"用法-1","link":"#用法-1","children":[]}]},{"level":2,"title":"useMemo","slug":"usememo","link":"#usememo","children":[{"level":3,"title":"特点","slug":"特点-2","link":"#特点-2","children":[]},{"level":3,"title":"用法","slug":"用法-2","link":"#用法-2","children":[]}]},{"level":2,"title":"useCallback","slug":"usecallback","link":"#usecallback","children":[{"level":3,"title":"特点","slug":"特点-3","link":"#特点-3","children":[]},{"level":3,"title":"用法","slug":"用法-3","link":"#用法-3","children":[]}]},{"level":2,"title":"memo","slug":"memo","link":"#memo","children":[{"level":3,"title":"特点","slug":"特点-4","link":"#特点-4","children":[]},{"level":3,"title":"用法","slug":"用法-4","link":"#用法-4","children":[]}]}],"readingTime":{"minutes":2.65,"words":794},"filePathRelative":"posts/react/react.md","excerpt":"\\n<p>React是一个很有哲学意味的框架，它的很多运行机制都体现了“纯粹”的理念。</p>\\n<h2>useRef</h2>\\n<h3>特点</h3>\\n<p><code>ref</code>是一个脱围机制，避免React检测到它的变化，从而避免不必要的渲染。同时又不像普通变量在重渲染时被重置。</p>\\n<h3>用法</h3>\\n<p>通过<code>useRef</code>创建一个ref对象，通过<code>ref.current</code>访问该对象。</p>\\n<p>还可以操作DOM节点，需要在JSX上使用<code>ref</code>属性来指定。</p>\\n<h3>解决</h3>\\n<p>如果是自定义的组件，可以通过<code>forwardRef</code>来传递ref。暴露DOM对象时可以通过<code>useImperativeHandle</code>来只暴露必要的属性、事件等。</p>","autoDesc":true}');export{c as comp,p as data};
