import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as n,o as t}from"./app-BVnFUE4I.js";const o={};function r(a,l){return t(),e("div",null,l[0]||(l[0]=[n('<h1 id="data-link-layer-数据链路层" tabindex="-1"><a class="header-anchor" href="#data-link-layer-数据链路层"><span>Data Link Layer (数据链路层)</span></a></h1><h2 id="function-功能" tabindex="-1"><a class="header-anchor" href="#function-功能"><span>Function( 功能)</span></a></h2><ul><li><strong>服务接口</strong> 向网络层提供一个服务接口 三种服务： <ul><li>无确认的无连接服务 <ul><li>错误率低</li><li>实时性高</li><li>Most LANs</li></ul></li><li>有确认的无连接服务 <ul><li>不可靠，但是每帧都会确认</li><li>例如无线局域网，802.11</li></ul></li><li>有确认的面向连接服务 <ul><li>WAN, P2P</li><li>建立连接、传输帧、释放</li><li>确保每一帧刚好传输一次、帧有序</li></ul></li></ul></li><li><strong>成帧</strong> 将网络层传下来的数据封装成帧 <ul><li>帧头：帧同步、帧长度、帧校验序列</li><li>有效载荷：数据</li><li>帧尾：帧校验序列</li></ul><blockquote><p>数据包和帧的关系：数据包是网络层传下来的，帧是数据链路层传下去的</p></blockquote></li><li><strong>传输错误处理</strong> 比如检错、纠错</li><li><strong>调节数据流量</strong> 比如流量控制，确保发送方不会淹没接收方</li></ul><h2 id="framing-成帧" tabindex="-1"><a class="header-anchor" href="#framing-成帧"><span>Framing (成帧)</span></a></h2><ul><li><strong>字节计数法</strong>：帧头中包含一个计数字段，表示帧中字节数</li><li><strong>标志字节法</strong>：帧头和帧尾包含特殊的字节，用于标识帧的开始和结束</li><li><strong>标志比特法</strong>：帧头和帧尾包含特殊的比特模式，用于标识帧的开始和结束</li><li><strong>物理层违例编码法</strong>：利用物理层编码违例外，标识帧的开始和结束</li></ul><blockquote><p>备注：此处字节=字符</p></blockquote><h3 id="字符计数" tabindex="-1"><a class="header-anchor" href="#字符计数"><span>字符计数</span></a></h3><p>每一帧开头都有一个字符（character），表示这一帧总共有多少字符。</p><blockquote><p><strong>问题</strong></p></blockquote><p>如果发生传输错误，接收方就会失去同步，找不到帧开始的位置，发送方也不知道从哪里开始重传</p><h3 id="标志字节法" tabindex="-1"><a class="header-anchor" href="#标志字节法"><span>标志字节法</span></a></h3><p>每一帧开头和结尾都有一个特殊的字符，称为标志字节（flag byte），表示帧的开始和结束。 如果接收方失去同步，只需要搜索两个标志字符就能找到当前帧的的结束位置、下一帧的开始位置。</p><blockquote><p><strong>问题</strong></p></blockquote><p>如果数据中恰好出现标志字节，就会产生冲突，称为<strong>冲突逃逸字符</strong>（escape character）</p><blockquote><p>解决方案：<strong>字节填充（byte stuffing）</strong></p></blockquote><ul><li>如果数据中恰好出现标志字节，就在它前面加上一个特殊的字符，称为转义字符（escape character）</li><li>接收方的数据链路层在传输给网络层前需要处理转义字符</li><li>如果数据中恰好出现转义字符，就在它前面再加上一个转义字符</li><li>填充方案举例：PPP（Point-to-Point Protocol）</li></ul><blockquote><p>缺点：8比特的字节来区分边界，效率低</p></blockquote><h3 id="标志比特法" tabindex="-1"><a class="header-anchor" href="#标志比特法"><span>标志比特法</span></a></h3><p>每一帧开头和结尾都有一个特殊的比特模式，称为标志比特（flag bit），表示帧的开始和结束。</p><blockquote><p><strong>比特填充</strong></p></blockquote><ul><li>以六个连续的1，即111111作为定界符</li><li>如果数据中恰好出现六个连续的1，当遇到5个连续的1时，在后面插入一个比特0</li><li>接收方的数据链路层在传输给网络层前需要处理比特填充，遇到5个连续的1时，删除后面插入的比特0</li></ul><blockquote><p><strong>相比标志字符法</strong></p><ul><li>传输效率高</li><li>划分级别在比特级别，而不是字符级别</li><li>帧可以包含任意大小单元</li></ul></blockquote><p>现实中的运用例子：USB</p><h3 id="物理层违例编码法" tabindex="-1"><a class="header-anchor" href="#物理层违例编码法"><span>物理层违例编码法</span></a></h3><p>核心思想：选择的定界符不会在数据中出现</p><p>方案：</p><ol><li>4B/5B</li><li>前导码</li></ol><ul><li>存在很长的前导码，可以用作定界符</li><li><strong>例子</strong>： 以太网，802.11</li></ul><ol start="3"><li>曼彻斯特编码</li></ol><ul><li>周期性的跳变，可以用作定界符</li></ul><h2 id="error-control-错误控制" tabindex="-1"><a class="header-anchor" href="#error-control-错误控制"><span>Error Control (错误控制)</span></a></h2><blockquote><p><strong>错误</strong></p><ul><li>差错</li><li>丢失</li><li>乱序</li><li>重复</li></ul></blockquote><blockquote><p><strong>解决方案</strong></p><ul><li><a href="#error-detection-and-correction-%E6%A3%80%E9%94%99%E5%92%8C%E7%BA%A0%E9%94%99">eror detection (检错)</a></li><li>Feedback: 反馈 <ul><li>Positive Acknowledgment (PA)</li><li>Negative Acknowledgment (NA)</li></ul></li><li>Timer：计时器</li><li>Sequence Number：序列号</li></ul></blockquote><h2 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制"><span>流量控制</span></a></h2><h3 id="feedback-based-flow-control-基于反馈的流量控制" tabindex="-1"><a class="header-anchor" href="#feedback-based-flow-control-基于反馈的流量控制"><span>feedback-based flow control(基于反馈的流量控制)</span></a></h3><h3 id="rate-based-flow-control-基于速率的流量控制" tabindex="-1"><a class="header-anchor" href="#rate-based-flow-control-基于速率的流量控制"><span>rate-based flow control(基于速率的流量控制)</span></a></h3><h2 id="error-detection-and-correction-检错和纠错" tabindex="-1"><a class="header-anchor" href="#error-detection-and-correction-检错和纠错"><span>Error Detection and Correction (检错和纠错)</span></a></h2><h3 id="策略" tabindex="-1"><a class="header-anchor" href="#策略"><span>策略</span></a></h3><ol><li>纠错码，使用纠错码的技术叫FEC（Forward Error Correction）</li></ol><ul><li>在发送的数据中包含信息，让接受发推断发生了什么错误 (what)</li><li>适用于容易出错的、有噪声的信道，例如无线链路</li></ul><ol start="2"><li>检错码</li></ol><ul><li>在发送的数据中包含信息，让接受方判断数据是否出错（is）</li><li>适用于不容易出错的，例如光纤</li></ul><h3 id="两种错误模型" tabindex="-1"><a class="header-anchor" href="#两种错误模型"><span>两种错误模型</span></a></h3><ol><li>单比特错误:极端热噪声淹没了信号</li><li>突发性错误（源自物理过程）</li></ol><p><strong>对比</strong>：</p><ul><li>多个单比特，如果错误是独立的，可能覆盖覆盖范围很广，导致多个数据块出错</li><li>突发错误一般集中在一个数据块，但是这比单个比特更难纠正</li></ul><blockquote><p><strong>补充：erase channel(擦除信道):</strong> 接受的模拟信号远离了0，1的预期值，相比于比特翻转，这更容易发现那个bit出错了。</p></blockquote><h3 id="纠错码" tabindex="-1"><a class="header-anchor" href="#纠错码"><span>纠错码</span></a></h3><p>将冗余信息加入数据：m个数据位，r个冗余位，总共有n=m+r个位 码字：数据位和冗余位组成的序列 码率：数据位和码字的比率，m/n</p><ul><li><strong>海明距离</strong>：两个码字之间，对应位置不同字符的个数 <ul><li>例如：0000000000, 0000011111, 1111100000, and 1111111111</li><li>Hamming distance is 5，因为任意字串之间转换都需要改变5个字符</li></ul></li><li><strong>最小海明距离</strong>：两个码字之间，对应位置不同字符的最小个数</li><li>为了检测d个错误，需要d+1的编码方案</li><li>为了纠正d个错误，需要2d+1的编码方案</li></ul><blockquote><p><strong>例子</strong> 0000000000, 0000011111, 1111100000, 1111111111, 距离为5，那么它可以纠正最多2个错误 比如如果是发送了0000011111，接收方收到了0000000111，发生了两个错误，那么接受发还是可以选择最接近的0000011111，从而纠正错误 比如如果是发送了0000000000，接收方收到了0000000111，那么它就不能正确的纠错了</p></blockquote><p>校验位数量如何最少：m+r+1 &lt;= 2^r</p><h4 id="hamming-code-海明码" tabindex="-1"><a class="header-anchor" href="#hamming-code-海明码"><span>Hamming Code（海明码）</span></a></h4><p>海明码能发现多位错误,但只能纠正一位错，若用在纠正传输中出现突发性差错时可以采用下述方法:将连续P个码字排成一个矩阵，每行一个码字。如果发生突发长度≤P的突发错误，那么在P个码字中最多每个码字有一位有差错，正好由海明码能纠正。</p><blockquote><ul><li>确定编码数量： <ul><li>由2^r &gt;= m+r+1，可以确定需要r个校验位</li></ul></li><li>确定每个校验位的位置： <ul><li>从1开始，2的幂次方，即1, 2, 4, 8, 16, 32, 64, 128, ...</li></ul></li><li>拼接校验位和数据位，得到n+r位的码字</li><li>校验位的值： <ul><li>对于第i（i=1,2,3...）个校验位，从当前校验位所在位置开始（校验位初始化值为0），若用一个tmp来表示校验位的值，tmp = 0，将tmp<sup>=码字位，并且每隔2</sup>（i-1）个位置再次异或，得到校验位的值。</li><li>（校验位的值的意义就是判断这些统计的部分里的1的个数是否为奇数（tmp=1）或偶数（tmp=0））</li></ul></li></ul></blockquote><p>接收方收到码字后，用同样的方法计算新的校验位的值，并将重新计算出来的校验位依次，从二进制低位到高位排列</p><blockquote><ul><li>如果二进制数最终代表0，那么就没有错误</li><li>否则，如果出错了一位，那么二进制所代表的数就是码字出错的位置 <ul><li>纠正：将计算出来的出错位置取反，得到正确的码字</li></ul></li></ul></blockquote>',57)]))}const u=i(o,[["render",r],["__file","DataLinkLayer.html.vue"]]),p=JSON.parse('{"path":"/posts/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DataLinkLayer.html","title":"Data Link Layer (数据链路层)","lang":"zh-CN","frontmatter":{"description":"Data Link Layer (数据链路层) Function( 功能) 服务接口 向网络层提供一个服务接口 三种服务： 无确认的无连接服务 错误率低 实时性高 Most LANs 有确认的无连接服务 不可靠，但是每帧都会确认 例如无线局域网，802.11 有确认的面向连接服务 WAN, P2P 建立连接、传输帧、释放 确保每一帧刚好传输一次、帧有序...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DataLinkLayer.html"}],["meta",{"property":"og:site_name","content":"DayDreamer的个人博客"}],["meta",{"property":"og:title","content":"Data Link Layer (数据链路层)"}],["meta",{"property":"og:description","content":"Data Link Layer (数据链路层) Function( 功能) 服务接口 向网络层提供一个服务接口 三种服务： 无确认的无连接服务 错误率低 实时性高 Most LANs 有确认的无连接服务 不可靠，但是每帧都会确认 例如无线局域网，802.11 有确认的面向连接服务 WAN, P2P 建立连接、传输帧、释放 确保每一帧刚好传输一次、帧有序..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Data Link Layer (数据链路层)\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DayDreamer\\",\\"url\\":\\"https://floatDreamWithSong.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Function( 功能)","slug":"function-功能","link":"#function-功能","children":[]},{"level":2,"title":"Framing (成帧)","slug":"framing-成帧","link":"#framing-成帧","children":[{"level":3,"title":"字符计数","slug":"字符计数","link":"#字符计数","children":[]},{"level":3,"title":"标志字节法","slug":"标志字节法","link":"#标志字节法","children":[]},{"level":3,"title":"标志比特法","slug":"标志比特法","link":"#标志比特法","children":[]},{"level":3,"title":"物理层违例编码法","slug":"物理层违例编码法","link":"#物理层违例编码法","children":[]}]},{"level":2,"title":"Error Control (错误控制)","slug":"error-control-错误控制","link":"#error-control-错误控制","children":[]},{"level":2,"title":"流量控制","slug":"流量控制","link":"#流量控制","children":[{"level":3,"title":"feedback-based flow control(基于反馈的流量控制)","slug":"feedback-based-flow-control-基于反馈的流量控制","link":"#feedback-based-flow-control-基于反馈的流量控制","children":[]},{"level":3,"title":"rate-based flow control(基于速率的流量控制)","slug":"rate-based-flow-control-基于速率的流量控制","link":"#rate-based-flow-control-基于速率的流量控制","children":[]}]},{"level":2,"title":"Error Detection and Correction (检错和纠错)","slug":"error-detection-and-correction-检错和纠错","link":"#error-detection-and-correction-检错和纠错","children":[{"level":3,"title":"策略","slug":"策略","link":"#策略","children":[]},{"level":3,"title":"两种错误模型","slug":"两种错误模型","link":"#两种错误模型","children":[]},{"level":3,"title":"纠错码","slug":"纠错码","link":"#纠错码","children":[]}]}],"readingTime":{"minutes":6.41,"words":1923},"filePathRelative":"posts/专业课/计算机网络/DataLinkLayer.md","excerpt":"\\n<h2>Function( 功能)</h2>\\n<ul>\\n<li><strong>服务接口</strong> 向网络层提供一个服务接口\\n三种服务：\\n<ul>\\n<li>无确认的无连接服务\\n<ul>\\n<li>错误率低</li>\\n<li>实时性高</li>\\n<li>Most LANs</li>\\n</ul>\\n</li>\\n<li>有确认的无连接服务\\n<ul>\\n<li>不可靠，但是每帧都会确认</li>\\n<li>例如无线局域网，802.11</li>\\n</ul>\\n</li>\\n<li>有确认的面向连接服务\\n<ul>\\n<li>WAN, P2P</li>\\n<li>建立连接、传输帧、释放</li>\\n<li>确保每一帧刚好传输一次、帧有序</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li><strong>成帧</strong> 将网络层传下来的数据封装成帧\\n<ul>\\n<li>帧头：帧同步、帧长度、帧校验序列</li>\\n<li>有效载荷：数据</li>\\n<li>帧尾：帧校验序列</li>\\n</ul>\\n<blockquote>\\n<p>数据包和帧的关系：数据包是网络层传下来的，帧是数据链路层传下去的</p>\\n</blockquote>\\n</li>\\n<li><strong>传输错误处理</strong> 比如检错、纠错</li>\\n<li><strong>调节数据流量</strong> 比如流量控制，确保发送方不会淹没接收方</li>\\n</ul>","autoDesc":true}');export{u as comp,p as data};
