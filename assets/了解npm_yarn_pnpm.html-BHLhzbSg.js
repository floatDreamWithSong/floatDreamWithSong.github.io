import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,o}from"./app-B4VCe033.js";const p={};function m(s,t){return o(),a("div",null,t[0]||(t[0]=[e("h1",{id:"node-package-management-tools-概览",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#node-package-management-tools-概览"},[e("span",null,"node package management tools 概览")])],-1),e("p",null,"虽然npm早期其实是给nodejs用于组织文件和库使用的，但是也已经扩展到前端工程化 npm 通过一个中央仓库，根据你的package.json的依赖结构自动化安装，而不像传统的CDN引入，本地.min.js引入的手动方式 package.lock.json 用于锁定依赖版本，这样即使环境转移后重新安装依赖，也不会因为依赖发布了新版本而影响已完成的项目的稳定性 npm安装时会在项目根目录下产生node_modules目录，里面按树形结构生成了依赖目录，第一层目录就是我们使用到的直接依赖，每层依赖的文件夹下 又安装了依赖的文件和依赖的依赖，如此递归。这样明显会产生很多重复的依赖模块导致依赖目录巨大，层次过于深，项目繁重",-1),e("p",null,"yarn是google搞出来的一种类似于改进版的npm，它会将npm依赖的依赖提升到第一层，降低目录结构深度， 但是一个依赖只会提升一个子依赖到浅层目录，依赖多了还是会有一些问题，同时还产生了“幽灵依赖”：",-1),e("blockquote",null,[e("p",null,"所谓幽灵依赖，即我们的项目并没有声明这个依赖，但是由于它作为了依赖的依赖而被提升，导致我们 在无意间导入并使用了被提升到浅层的依赖的依赖。 如果某一天项目组织关系发生变动，一个依赖被移除，它的子依赖也会被移除，但是我们并不知道我们使用了子依赖，从而使得项目崩溃")],-1),e("p",null,"pnpm(所谓perfect npm)，通过一个全局的.pnpm-store目录，当安装依赖时会将依赖储存于此，而node_nodules的一层依赖之下会对依赖进行link，link到 这个全局目录，这样不仅降低了node_modules的结构扁平化，也解决了“幽灵依赖”的问题",-1),e("p",null,"关于package.json 的dependency和devDependency，如果你直接npm i 的话其实没什么区别 但是npm i --production 就只会安装生产依赖而不会安装dev的 有一个peerDependency，一般发npm包会用。如果你想将你的代码打包成可使用的包并且不想要其他的第三方依赖从而保持你的代码纯洁， 就要在这里写，当然打包的一些配置项还是要写的，这个只是一个声明以便别人安装使用而不是用来帮助你打包结构的。",-1)]))}const i=n(p,[["render",m],["__file","了解npm_yarn_pnpm.html.vue"]]),l=JSON.parse('{"path":"/posts/npm/%E4%BA%86%E8%A7%A3npm_yarn_pnpm.html","title":"node package management tools 概览","lang":"zh-CN","frontmatter":{"cover":"/assets/images/cover2.jpg","icon":"pen-to-square","date":"2024-10-18T00:00:00.000Z","category":["npm"],"tag":["npm","node"],"star":true,"sticky":true,"description":"node package management tools 概览 虽然npm早期其实是给nodejs用于组织文件和库使用的，但是也已经扩展到前端工程化 npm 通过一个中央仓库，根据你的package.json的依赖结构自动化安装，而不像传统的CDN引入，本地.min.js引入的手动方式 package.lock.json 用于锁定依赖版本，这样即使环...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/npm/%E4%BA%86%E8%A7%A3npm_yarn_pnpm.html"}],["meta",{"property":"og:site_name","content":"DayDreamer的个人博客"}],["meta",{"property":"og:title","content":"node package management tools 概览"}],["meta",{"property":"og:description","content":"node package management tools 概览 虽然npm早期其实是给nodejs用于组织文件和库使用的，但是也已经扩展到前端工程化 npm 通过一个中央仓库，根据你的package.json的依赖结构自动化安装，而不像传统的CDN引入，本地.min.js引入的手动方式 package.lock.json 用于锁定依赖版本，这样即使环..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/assets/images/cover2.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://mister-hope.github.io/assets/images/cover2.jpg"}],["meta",{"name":"twitter:image:alt","content":"node package management tools 概览"}],["meta",{"property":"article:tag","content":"npm"}],["meta",{"property":"article:tag","content":"node"}],["meta",{"property":"article:published_time","content":"2024-10-18T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"node package management tools 概览\\",\\"image\\":[\\"https://mister-hope.github.io/assets/images/cover2.jpg\\"],\\"datePublished\\":\\"2024-10-18T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DayDreamer\\",\\"url\\":\\"https://floatDreamWithSong.github.io\\"}]}"]]},"headers":[],"readingTime":{"minutes":2.29,"words":687},"filePathRelative":"posts/npm/了解npm,yarn,pnpm.md","localizedDate":"2024年10月18日","excerpt":"\\n<p>虽然npm早期其实是给nodejs用于组织文件和库使用的，但是也已经扩展到前端工程化\\nnpm 通过一个中央仓库，根据你的package.json的依赖结构自动化安装，而不像传统的CDN引入，本地.min.js引入的手动方式\\npackage.lock.json 用于锁定依赖版本，这样即使环境转移后重新安装依赖，也不会因为依赖发布了新版本而影响已完成的项目的稳定性\\nnpm安装时会在项目根目录下产生node_modules目录，里面按树形结构生成了依赖目录，第一层目录就是我们使用到的直接依赖，每层依赖的文件夹下\\n又安装了依赖的文件和依赖的依赖，如此递归。这样明显会产生很多重复的依赖模块导致依赖目录巨大，层次过于深，项目繁重</p>","autoDesc":true}');export{i as comp,l as data};
